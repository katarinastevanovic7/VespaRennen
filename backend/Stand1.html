<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>GPS Tracker mit Umschaltbutton</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    .button {
      position: absolute;
      top: 10px;
      padding: 10px;
      font-size: 16px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      z-index: 1000;
    }
    #startBtn { left: 10px; }
    #backBtn { left: 140px; background-color: #dc3545; }
    #toggleBtn { left: 270px; background-color: orange; }

    #infoBox {
      position: absolute;
      top: 10px;
      right: 10px;
      background: white;
      padding: 8px 12px;
      font-family: sans-serif;
      font-size: 14px;
      border-radius: 5px;
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
      z-index: 1000;
      text-align: right;
      min-width: 160px;
      line-height: 1.3em;
    }
  </style>
</head>
<body>
  <button id="startBtn" class="button">ğŸ“ Start Tracking</button>
  <button id="backBtn" class="button">ğŸ”™ ZurÃ¼ck</button>
  <button id="toggleBtn" class="button">â¸ï¸ Pause</button>
  <div id="infoBox">
    â±ï¸ Letztes Update: â€“<br>
    ğŸš€ Geschwindigkeit: â€“<br>
    ğŸ§­ Gesamtstrecke: â€“<br>
    ğŸ“ Reststrecke: â€“<br>
    âœ… ZurÃ¼ckgelegt: â€“<br>
    â³ Timer: 05:00.000
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

  <script>
    // Karte initialisieren (mit Default View, wird spÃ¤ter durch Standort Ã¼berschrieben)
   const map = L.map('map').setView([47.7, 9.0], 17); 
 const satellite = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  maxZoom: 19,
  attribution: 'Tiles Â© Esri'
});

const labels = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
  maxZoom: 19,
  attribution: 'Labels Â© Esri'
});

L.layerGroup([satellite, labels]).addTo(map);


    // Beim Laden einmal aktuellen Standort holen und Karte dahin zentrieren
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const lat = pos.coords.latitude;
          const lng = pos.coords.longitude;
          map.setView([lat, lng], 17);  // Zoom bleibt 17
        },
        (err) => {
          console.warn("Standort konnte nicht ermittelt werden, Karte bleibt auf Default.");
        },
        {
          enableHighAccuracy: true,
          timeout: 5000,
          maximumAge: 0
        }
      );
    } else {
      console.warn("Geolocation wird nicht unterstÃ¼tzt, Karte bleibt auf Default.");
    }

    // Globale Variablen
    const routePoints = [];
    const pointMarkers = [];
    let polyline = null;
    let turfLine = null;
    let trackingStarted = false;

    let lastUpdateTime = null;
    let currentSpeed = null;
    let gpsWatcher = null;
    let gpsPaused = false;

    let distanceToGoal = null;
    let distanceCovered = 0;

    let countdownDuration = 5 * 60 * 1000; // 5 Minuten in ms
    let countdownStart = null;
    let countdownInterval = null;

    let averageSpeed = 0; // m/s
let lapCountEstimate = 0;
let suggestedSpeedLower = null;
let suggestedSpeedUpper = null;

const useSimulation = true;
let simulationSpeedKmh = 30; // Startgeschwindigkeit
let simulationInterval = null;
let simulationDistance = 0;


window.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById("simSpeedSlider");
  const label = document.getElementById("simSpeedLabel");
  if (slider && label) {
    slider.addEventListener("input", () => {
      simulationSpeedKmh = Number(slider.value);
      label.textContent = slider.value;
    });
  }
});



    const infoBox = document.getElementById("infoBox");
    const toggleBtn = document.getElementById("toggleBtn");

    // Timer Anzeige in infoBox separat updaten
    function formatTime(ms) {
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const milliseconds = ms % 1000;

      return `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}.${String(milliseconds).padStart(3,'0')}`;
    }

    function updateInfoBoxTime(remainingMs) {
      const timeStr = formatTime(Math.max(remainingMs, 0));
      // Timer immer als letzte Zeile hinzufÃ¼gen
      infoBox.innerHTML = infoBox.innerHTML.replace(/â³ Timer: .*$/m, `â³ Timer: ${timeStr}`);
    }

    function startCountdown() {
      countdownStart = Date.now();
      if (countdownInterval) clearInterval(countdownInterval);
      countdownInterval = setInterval(() => {
        const elapsed = Date.now() - countdownStart;
        const remaining = countdownDuration - elapsed;

        if (remaining <= 0) {
          clearInterval(countdownInterval);
          updateInfoBoxTime(0);
        } else {
          updateInfoBoxTime(remaining);
        }
      }, 50);
    }

    // InfoBox mit allen Werten aktualisieren (auÃŸer Timer, der lÃ¤uft separat)
    function updateInfoBox() {
  let timeText = "â±ï¸ Letztes Update: â€“";
  let speedText = "ğŸš€ Geschwindigkeit: â€“";
  let restDistText = "ğŸ“ Reststrecke: â€“";
  let coveredDistText = "âœ… ZurÃ¼ckgelegt: â€“";
  let totalDistText = "ğŸ§­ Gesamtstrecke: â€“";
  let avgSpeedText = "ğŸ“ˆ Ã˜-Tempo: â€“";
  let suggSpeedText = "ğŸ¯ Ziel: â€“ / â€“";

  if (lastUpdateTime) {
    const delta = Date.now() - lastUpdateTime;
    timeText = `â±ï¸ Letztes Update: ${(delta / 1000).toFixed(2)} s`;
  }
  if (currentSpeed !== null) {
    const kmh = (currentSpeed * 3.6).toFixed(1);
    speedText = `ğŸš€ Geschwindigkeit: ${kmh} km/h`;
  }
  if (distanceToGoal !== null) {
    restDistText = `ğŸ“ Reststrecke: ${distanceToGoal.toFixed(1)} m`;
  }
  if (distanceCovered !== null) {
    coveredDistText = `âœ… ZurÃ¼ckgelegt: ${distanceCovered.toFixed(1)} m`;
  }
  if (typeof totalDistance === "number") {
    totalDistText = `ğŸ§­ Gesamtstrecke: ${totalDistance.toFixed(1)} m`;
  }

  const elapsed = countdownStart ? (Date.now() - countdownStart) / 1000 : 0;
  if (elapsed > 0 && distanceCovered > 0) {
    averageSpeed = distanceCovered / elapsed; // m/s
    const kmh = (averageSpeed * 3.6).toFixed(1);
    avgSpeedText = `ğŸ“ˆ Ã˜-Tempo: ${kmh} km/h`;

    const remainingTime = (countdownDuration - (Date.now() - countdownStart)) / 1000;
    const lapLength = totalDistance;
    if (lapLength > 0 && remainingTime > 0) {
      lapCountEstimate = (averageSpeed * remainingTime) / lapLength;

      const lowerTarget = Math.floor(lapCountEstimate);
      const upperTarget = lowerTarget + 1;

      const speedLower = (lapLength * lowerTarget) / remainingTime;
      const speedUpper = (lapLength * upperTarget) / remainingTime;

      suggestedSpeedLower = (speedLower * 3.6).toFixed(1);
      suggestedSpeedUpper = (speedUpper * 3.6).toFixed(1);

      suggSpeedText = `ğŸ¯ Ziel: ${suggestedSpeedLower} â†“ / ${suggestedSpeedUpper} â†‘ km/h`;
    }
  }

  const timerLine = infoBox.innerHTML.match(/â³ Timer: .*/);
  infoBox.innerHTML = `${timeText}<br>${speedText}<br>${avgSpeedText}<br>${restDistText}<br>${coveredDistText}<br>${totalDistText}<br>${suggSpeedText}<br>` + (timerLine ? timerLine[0] : `â³ Timer: 05:00.000`);
}


    // Update InfoBox regelmÃ¤ÃŸig
    setInterval(updateInfoBox, 200);

    // Strecke zeichnen und Punkte setzen
    map.on('click', function(e) {
      if (trackingStarted) return; // Keine Punkte wÃ¤hrend Tracking setzen

      const latlng = [e.latlng.lat, e.latlng.lng];
      routePoints.push(latlng);

      // Erster Punkt magenta, alle anderen blau
      const markerColor = routePoints.length === 1 ? 'magenta' : 'blue';
      const marker = L.circleMarker(latlng, { radius: 5, color: markerColor }).addTo(map);
      pointMarkers.push(marker);

      updateDistance();
      drawPolyline();
    });

    function drawPolyline() {
      if (polyline) map.removeLayer(polyline);
      if (routePoints.length >= 2) {
        polyline = L.polyline(routePoints, { color: 'blue' }).addTo(map);
      }
    }

    function updateDistance() {
      totalDistance = 0;
      if (routePoints.length >= 2) {
        for (let i = 1; i < routePoints.length; i++) {
          const from = turf.point([routePoints[i - 1][1], routePoints[i - 1][0]]);
          const to = turf.point([routePoints[i][1], routePoints[i][0]]);
          totalDistance += turf.distance(from, to, { units: 'meters' });
        }
      }
    }

    // "ZurÃ¼ck"-Button - letzter Punkt lÃ¶schen
    document.getElementById("backBtn").addEventListener("click", () => {
      if (trackingStarted || routePoints.length === 0) return;

      routePoints.pop();
      const lastMarker = pointMarkers.pop();
      if (lastMarker) map.removeLayer(lastMarker);

      updateDistance();
      drawPolyline();
    });

    // "Start Tracking"-Button
    document.getElementById("startBtn").addEventListener("click", () => {
      if (routePoints.length < 2) {
        alert("Bitte zuerst eine Strecke zeichnen!");
        return;
      }

      // Strecke schlieÃŸen (Start = Ziel), falls noch nicht
      if (!routePoints[0].every((val, index) => val === routePoints[routePoints.length - 1][index])) {
        routePoints.push(routePoints[0]);
      }

      updateDistance();
      drawPolyline();

      trackingStarted = true;
      document.getElementById("startBtn").disabled = true;
      document.getElementById("backBtn").disabled = true;

      turfLine = turf.lineString(routePoints.map(p => [p[1], p[0]]));

      distanceCovered = 0;
      distanceToGoal = totalDistance;

      startLiveGPS();
      startCountdown();
    });

    // Umschaltbutton Pause / Weiter
    toggleBtn.addEventListener("click", () => {
      if (!trackingStarted) return;

      if (!gpsPaused) {
        // pausieren
        if (gpsWatcher !== null) {
          navigator.geolocation.clearWatch(gpsWatcher);
          gpsWatcher = null;
        }
        gpsPaused = true;
        toggleBtn.innerText = "â–¶ï¸ Weiter";
        toggleBtn.style.backgroundColor = "green";
      } else {
        // weiter
        startLiveGPS();
        gpsPaused = false;
        toggleBtn.innerText = "â¸ï¸ Pause";
        toggleBtn.style.backgroundColor = "orange";
      }
    });

    // GPS Live Tracking
    function startLiveGPS() {
  if (useSimulation) {
    startSimulation();
    return;
  }

  if (!navigator.geolocation) {
    alert("GPS wird nicht unterstÃ¼tzt.");
    return;
  }

  gpsWatcher = navigator.geolocation.watchPosition(
    onGpsPosition,
    err => {
      alert("GPS-Fehler: " + err.message);
    },
    {
      enableHighAccuracy: true,
      maximumAge: 1000,
      timeout: 5000
    }
  );
}

    function startSimulation() {
  const intervalTime = 1000; // alle 1 Sekunde
  const speedMps = simulationSpeedKmh / 3.6;

  simulationInterval = setInterval(() => {
    simulationDistance += speedMps; // Fortschritt

    if (typeof totalDistance !== "number" || !turfLine) return;

    let t = (simulationDistance % totalDistance) / totalDistance;
    const point = turf.along(turfLine, totalDistance * t, { units: 'meters' });
    const lng = point.geometry.coordinates[0];
    const lat = point.geometry.coordinates[1];

    // Fake-GPS an vorhandene Funktion Ã¼bergeben
    onGpsPosition({
      coords: {
        latitude: lat,
        longitude: lng,
        speed: speedMps
      }
    });
  }, intervalTime);
}
function onGpsPosition(pos) {
  const lat = pos.coords.latitude;
  const lng = pos.coords.longitude;
  const speed = pos.coords.speed;
  if (!firstPositionSet) {
  countdownStart = Date.now();
  firstPositionSet = true;
}


  lastUpdateTime = Date.now();
  currentSpeed = speed !== null ? speed : null;

  const currentPoint = turf.point([lng, lat]);
  const snapped = turf.nearestPointOnLine(turfLine, currentPoint);
  const snappedLatLng = [snapped.geometry.coordinates[1], snapped.geometry.coordinates[0]];

  // Marker aktualisieren
  pointMarkers.forEach(m => {
    if (m.options.color === 'red') map.removeLayer(m);
  });

  const redMarker = L.circleMarker(snappedLatLng, { color: 'red', radius: 6 }).addTo(map);
  pointMarkers.push(redMarker);
  const gpsMarker = L.circleMarker([lat, lng], { color: 'yellow', radius: 4 }).addTo(map);
  pointMarkers.push(gpsMarker);

  // Distanzberechnung
  let nearestIndex = 0;
  let minDist = Infinity;
  for (let i = 0; i < routePoints.length; i++) {
    const pt = routePoints[i];
    const dist = turf.distance(
      turf.point([pt[1], pt[0]]),
      turf.point([snapped.geometry.coordinates[0], snapped.geometry.coordinates[1]]),
      { units: 'meters' }
    );
    if (dist < minDist) {
      minDist = dist;
      nearestIndex = i;
    }
  }

  let remainingDist = 0;
  const n = routePoints.length;
  for (let i = nearestIndex; i != 0; i = (i + 1) % n) {
    const current = turf.point([routePoints[i][1], routePoints[i][0]]);
    const next = turf.point([routePoints[(i + 1) % n][1], routePoints[(i + 1) % n][0]]);
    remainingDist += turf.distance(current, next, { units: 'meters' });
  }
  distanceToGoal = remainingDist;
  distanceCovered = totalDistance - distanceToGoal;

  map.setView([lat, lng]);
}



  </script>
  <div style="position:absolute; bottom:10px; left:10px; background:white; padding:8px 12px; border-radius:8px; font-family:sans-serif; font-size:14px; box-shadow:0 0 4px rgba(0,0,0,0.3); z-index:1000;">
  Geschwindigkeit (km/h): <span id="simSpeedLabel">30</span><br>
  <input type="range" id="simSpeedSlider" min="5" max="100" value="30">
</div>
<script>
  window.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById("simSpeedSlider");
    const label = document.getElementById("simSpeedLabel");
    if (slider && label) {
      slider.addEventListener("input", () => {
        simulationSpeedKmh = Number(slider.value);
        label.textContent = slider.value;
      });
    }
  });
</script>

<div style="position:absolute; bottom:10px; left:10px; background:white; padding:8px 12px; border-radius:8px; font-family:sans-serif; font-size:14px; box-shadow:0 0 4px rgba(0,0,0,0.3); z-index:1000;">
  Geschwindigkeit (km/h): <span id="simSpeedLabel">30</span><br>
  <input type="range" id="simSpeedSlider" min="5" max="100" value="30">
</div>

</body>
</html>
