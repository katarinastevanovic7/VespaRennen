<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>GPS Tracker mit Umschaltbutton</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    .button {
      position: absolute;
      top: 10px;
      padding: 10px;
      font-size: 16px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      z-index: 1000;
    }
    #startBtn { left: 10px; }
    #backBtn { left: 140px; background-color: #dc3545; }
    #toggleBtn { left: 270px; background-color: orange; }

    #infoBox {
      position: absolute;
      top: 10px;
      right: 10px;
      background: white;
      padding: 8px 12px;
      font-family: sans-serif;
      font-size: 14px;
      border-radius: 5px;
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
      z-index: 1000;
      text-align: right;
      min-width: 160px;
      line-height: 1.3em;
    }
  </style>
</head>
<body>
  <button id="startBtn" class="button">üìç Start Tracking</button>
  <button id="backBtn" class="button">üîô Zur√ºck</button>
  <button id="toggleBtn" class="button">‚è∏Ô∏è Pause</button>
  <div id="infoBox">
    ‚è±Ô∏è Letztes Update: ‚Äì<br>
    üöÄ Geschwindigkeit: ‚Äì<br>
    üß≠ Gesamtstrecke: ‚Äì<br>
    üìè Reststrecke: ‚Äì<br>
    ‚úÖ Zur√ºckgelegt: ‚Äì<br>
    ‚è≥ Timer: 05:00.000
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
<script> 
  (function(){
"use strict";
    // Karte initialisieren (mit Default View, wird sp√§ter durch Standort √ºberschrieben)
   const map = L.map('map').setView([47.7, 9.0], 17);
 const satellite = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  maxZoom: 19,
  attribution: 'Tiles ¬© Esri'
});

const labels = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
  maxZoom: 19,
  attribution: 'Labels ¬© Esri'
});

L.layerGroup([satellite, labels]).addTo(map);

    // Beim Laden einmal aktuellen Standort holen und Karte dahin zentrieren
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const lat = pos.coords.latitude;
          const lng = pos.coords.longitude;
          map.setView([lat, lng], 17);  // Zoom bleibt 17
        },
        (err) => {
          console.warn("Standort konnte nicht ermittelt werden, Karte bleibt auf Default.");
        },
        {
          enableHighAccuracy: true,
          timeout: 5000,
          maximumAge: 0
        }
      );
    } else {
      console.warn("Geolocation wird nicht unterst√ºtzt, Karte bleibt auf Default.");
    }

    // Globale Variablen
    const routePoints = [];
    const pointMarkers = [];
    let polyline = null;
    let turfLine = null;
    let trackingStarted = false;

    let lastUpdateTime = null;
    let currentSpeed = null;
    let gpsWatcher = null;
    let gpsPaused = false;

    let distanceToGoal = null;
    let distanceCovered = 0;
    let finalDistance = null;

    const COUNTDOWN_TOTAL = 5 * 60 * 1000; // 5 Minuten in ms
    let countdownRemaining = COUNTDOWN_TOTAL;
    let countdownStart = null;
    let countdownInterval = null;
    let pauseTime = null;
    let totalPausedTime = 0;

    let averageSpeed = 0; // m/s
    let suggestedSpeedLower = null;
    let suggestedSpeedUpper = null;
    let firstPositionSet = false;
    let firstTrackingTime = null;
    let lapsLower = null;
    let lapsUpper = null;

    let totalDistanceTravelled = 0;
    let prevAlong = null;
    let lapsCompleted = 0;

    let totalDistance = 0;

    let speedSamples = [];
    let smoothedSpeed = null;
    const SMOOTHING_FACTOR = 0.2; // Einfluss der aktuellen Geschwindigkeit
    const MAX_SPEED = 70 / 3.6; // 70 km/h in m/s

    function centerMap(lat, lng, zoom = null) {
      map.setView([lat, lng], zoom || map.getZoom());
    }

    function getMarkerColor(index) {
      return index === 0 ? 'magenta' : 'blue';
    }

    function formatTime(ms) {
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const milliseconds = ms % 1000;
      return `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}.${String(milliseconds).padStart(3,'0')}`;
    }

    function updateInfoBoxTime(remainingMs) {
      const timeStr = formatTime(Math.max(remainingMs, 0));
      infoBox.innerHTML = infoBox.innerHTML.replace(/‚è≥ Timer: .*$/m, `‚è≥ Timer: ${timeStr}`);
    }

    function startCountdown() {
      countdownStart = Date.now();
      if (countdownInterval) clearInterval(countdownInterval);
      const countdownStartTime = Date.now(); // echte Startzeit merken

countdownInterval = setInterval(() => {
  const now = Date.now();
  const paused = totalPausedTime + (gpsPaused && pauseTime ? now - pauseTime : 0);
  const elapsed = now - countdownStartTime - paused;
  const remaining = COUNTDOWN_TOTAL - elapsed;

  updateInfoBoxTime(Math.max(remaining, 0));

  if (remaining <= 0) {
    clearInterval(countdownInterval);
    finishRun();
  }
}, 100);
    }
//timer synchronisation
setInterval(() => {
  if (!trackingStarted) {
    fetch('http://localhost:3000/api/start-tracking')
      .then(res => res.json())
      .then(data => {
        if (data.start) {
          console.log('üö¶ Start-Signal empfangen');
          startBtn.click();
        }
      });
  }

  // ‚ûï Pause-Signal abfragen
  fetch('http://localhost:3000/api/pause-tracking')
    .then(res => res.json())
    .then(data => {
      if (data.pause && !gpsPaused) {
        console.log('‚è∏Ô∏è Pause-Signal empfangen');
        toggleBtn.click(); // klickt auf Pause/Resume
      }
    });

  

  

  // Stop
fetch('http://localhost:3000/api/stop-tracking')
  .then(res => res.json())
  .then(data => {
    if (data.stop && trackingStarted) {
      console.log('üõë Stop-Signal empfangen');
      finishRun(); // oder location.reload() bei Bedarf
    }
  });

    // Resume
    fetch('http://localhost:3000/api/resume-tracking')
  .then(res => res.json())
  .then(data => {
    if (data.resume) {
      if (gpsPaused) {
        console.log('‚ñ∂Ô∏è Resume-Signal empfangen ‚Äì GPS ist pausiert ‚Üí toggling');
        toggleBtn.click(); // wirklich nur wenn pausiert
      } else {
        console.log('‚ÑπÔ∏è Resume-Signal empfangen ‚Äì aber bereits aktiv');
      }
    }
  });

  // ‚ûï Reset-Signal abfragen
  fetch('http://localhost:3000/api/reset-tracking')
    .then(res => res.json())
    .then(data => {
      if (data.reset) {
        console.log('üîÅ Reset-Signal empfangen');
        location.reload(); // einfacher Reset (neu laden)
      }
    });
}, 250);

    /*setInterval(() => {
  if (!trackingStarted) {
    fetch('http://localhost:3000/api/start-tracking')
      .then(res => res.json())
      .then(data => {
        if (data.start) {
          console.log('üö¶ Tracking-Start vom Server empfangen');
          startBtn.click(); // simuliert Klick auf Start-Button
        }
      });
  }
}, 1000); // alle 1 Sekunde pr√ºfen*/

    function updateInfoBox() {
      let timeText = "‚è±Ô∏è Letztes Update: ‚Äì";
      let speedText = "üöÄ Geschwindigkeit: ‚Äì";
      let restDistText = "üìè Reststrecke: ‚Äì";
      let coveredDistText = "‚úÖ Zur√ºckgelegt: ‚Äì";
      let totalDistText = "üß≠ Gesamtstrecke: ‚Äì";
      let avgSpeedText = "üìà √ò-Tempo: ‚Äì";
      let suggSpeedText = "üåü Ziel: ‚Äì / ‚Äì";

      if (lastUpdateTime) {
        let delta = Date.now() - lastUpdateTime;
        if (gpsPaused && pauseTime) {
          delta -= Date.now() - pauseTime;
        }
        timeText = `‚è±Ô∏è Letztes Update: ${(delta / 1000).toFixed(2)} s`;
      }
      if (currentSpeed !== null) {
        const kmh = (currentSpeed * 3.6).toFixed(1);
        speedText = `üöÄ Geschwindigkeit: ${kmh} km/h`;
      }
      if (distanceToGoal !== null) {
        restDistText = `üìè Reststrecke: ${distanceToGoal.toFixed(1)} m`;
      }
      if (distanceCovered !== null) {
        coveredDistText = `‚úÖ Zur√ºckgelegt: ${distanceCovered.toFixed(1)} m`;
      }
      if (typeof totalDistance === "number") {
        totalDistText = `üß≠ Gesamtstrecke: ${totalDistance.toFixed(1)} m`;
      }
      if (averageSpeed > 0) {
        const kmh = (averageSpeed * 3.6).toFixed(1);
        avgSpeedText = `üìà √ò-Tempo: ${kmh} km/h`;
      }

      if (firstTrackingTime && distanceCovered > 0) {
        const paused = totalPausedTime + (gpsPaused && pauseTime ? Date.now() - pauseTime : 0);
        const elapsedSec = (Date.now() - firstTrackingTime - paused) / 1000;
        if (elapsedSec > 0) {
          averageSpeed = distanceCovered / elapsedSec;
        }

        let remainingTime = countdownRemaining;
        if (countdownStart !== null) {
          remainingTime = countdownRemaining - (Date.now() - countdownStart);
        }
        remainingTime /= 1000;

        const lapLength = totalDistance;
        const baseCandidate = smoothedSpeed !== null
          ? 0.7 * smoothedSpeed + 0.3 * averageSpeed
          : (averageSpeed || 0);
        const baseline = baseCandidate > 0 ? baseCandidate : 0;
        if (remainingTime > 0 && lapLength > 0 && baseline > 0) {
          const predictedLaps = (distanceCovered + baseline * remainingTime) / lapLength;
          let lowerTarget = Math.floor(predictedLaps);
          if (lowerTarget < lapsCompleted) lowerTarget = lapsCompleted;
          const upperTarget = lowerTarget + 1;

          let speedLower = (lowerTarget * lapLength - distanceCovered) / remainingTime;
          let speedUpper = (upperTarget * lapLength - distanceCovered) / remainingTime;

          if (currentSpeed && speedLower >= currentSpeed) speedLower = currentSpeed * 0.9;
          if (currentSpeed && speedUpper <= currentSpeed) speedUpper = currentSpeed * 1.1;

          const validLower = speedLower > 0 && speedLower <= MAX_SPEED;
          const validUpper = speedUpper > 0 && speedUpper <= MAX_SPEED;

          lapsLower = (distanceCovered + speedLower * remainingTime) / lapLength;
          lapsUpper = (distanceCovered + speedUpper * remainingTime) / lapLength;

          if (validLower && validUpper) {
            suggestedSpeedLower = (speedLower * 3.6).toFixed(1);
            suggestedSpeedUpper = (speedUpper * 3.6).toFixed(1);
            suggSpeedText = `üåü Ziel: ${suggestedSpeedLower} ‚Üì (${lapsLower.toFixed(1)} R) / ${suggestedSpeedUpper} ‚Üë (${lapsUpper.toFixed(1)} R) km/h`;
          } else if (validLower) {
            suggestedSpeedLower = (speedLower * 3.6).toFixed(1);
            suggestedSpeedUpper = null;
            suggSpeedText = `üåü Ziel: ${suggestedSpeedLower} km/h (${lapsLower.toFixed(1)} R)`;
          } else if (validUpper) {
            suggestedSpeedLower = (speedUpper * 3.6).toFixed(1);
            suggestedSpeedUpper = null;
            suggSpeedText = `üåü Ziel: ${suggestedSpeedLower} km/h (${lapsUpper.toFixed(1)} R)`;

// Zielgeschwindigkeit und Runden an Backend senden
fetch('http://localhost:3000/api/target-speed', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    lower: suggestedSpeedLower,
    upper: suggestedSpeedUpper,
    lapsLower: lapsLower,
    lapsUpper: lapsUpper
  })
});

          }
        }
      }

      const timerLine = infoBox.innerHTML.match(/‚è≥ Timer: .*/);
      infoBox.innerHTML = `${timeText}<br>${speedText}<br>${avgSpeedText}<br>${restDistText}<br>${coveredDistText}<br>${totalDistText}<br>${suggSpeedText}<br>` + (timerLine ? timerLine[0] : `‚è≥ Timer: 05:00.000`);
    }

    setInterval(updateInfoBox, 200);

    map.on('click', function(e) {
      if (trackingStarted) return;
      const latlng = [e.latlng.lat, e.latlng.lng];
      routePoints.push(latlng);
      const markerColor = getMarkerColor(routePoints.length - 1);
      const marker = L.circleMarker(latlng, { radius: 5, color: markerColor }).addTo(map);
      pointMarkers.push(marker);
      updateDistance();
      drawPolyline();
    });

    function drawPolyline() {
      if (polyline) map.removeLayer(polyline);
      if (routePoints.length >= 2) {
        polyline = L.polyline(routePoints, { color: 'blue' }).addTo(map);
      }
    }

    function updateDistance() {
      totalDistance = 0;
      if (routePoints.length >= 2) {
        for (let i = 1; i < routePoints.length; i++) {
          const from = turf.point([routePoints[i - 1][1], routePoints[i - 1][0]]);
          const to = turf.point([routePoints[i][1], routePoints[i][0]]);
          totalDistance += turf.distance(from, to, { units: 'meters' });
        }
      }
    }

    backBtn.addEventListener("click", () => {
      if (trackingStarted || routePoints.length === 0) return;
      routePoints.pop();
      const lastMarker = pointMarkers.pop();
      if (lastMarker) map.removeLayer(lastMarker);
      updateDistance();
      drawPolyline();
    });

    startBtn.addEventListener("click", () => {
      if (routePoints.length < 2) {
        alert("Bitte zuerst eine Strecke zeichnen!");
        return;
      }
      if (!routePoints[0].every((val, index) => val === routePoints[routePoints.length - 1][index])) {
        routePoints.push(routePoints[0]);
      }
      updateDistance();
      drawPolyline();
      trackingStarted = true;
      startBtn.disabled = true;
      backBtn.disabled = true;

      turfLine = turf.lineString(routePoints.map(p => [p[1], p[0]]));
      firstPositionSet = false;
      speedSamples = [];
      distanceCovered = 0;
      distanceToGoal = totalDistance;
      totalDistanceTravelled = 0;
      prevAlong = null;
      lapsCompleted = 0;
      countdownRemaining = COUNTDOWN_TOTAL;
      totalPausedTime = 0;
      pauseTime = null;

      startLiveGPS();
    });

    toggleBtn.addEventListener("click", () => {
      if (!trackingStarted) return;
      if (!gpsPaused) {
        if (gpsWatcher !== null) {
          navigator.geolocation.clearWatch(gpsWatcher);
          gpsWatcher = null;
        }
        if (countdownInterval) {
          countdownRemaining = Math.max(countdownRemaining - (Date.now() - countdownStart), 0);
          clearInterval(countdownInterval);
          countdownStart = null;
          updateInfoBoxTime(countdownRemaining);
        }
        pauseTime = Date.now();
        gpsPaused = true;
        toggleBtn.innerText = "‚ñ∂Ô∏è Weiter";
        toggleBtn.style.backgroundColor = "green";
      } else {
        if (pauseTime !== null) {
          const pauseDelta = Date.now() - pauseTime;
          lastUpdateTime += pauseDelta;
          totalPausedTime += pauseDelta;
          pauseTime = null;
        }
        startLiveGPS();
        gpsPaused = false;
        startCountdown();
        toggleBtn.innerText = "‚è∏Ô∏è Pause";
        toggleBtn.style.backgroundColor = "orange";
      }
    });

    function startLiveGPS() {
      if (!navigator.geolocation) {
        alert("GPS wird nicht unterst√ºtzt.");
        return;
      }

      gpsWatcher = navigator.geolocation.watchPosition(
        onGpsPosition,
        err => {
          alert("GPS-Fehler: " + err.message);
        },
        {
          enableHighAccuracy: true,
          maximumAge: 1000,
          timeout: 5000
        }
      );
    }

    function onGpsPosition(pos) {
      const lat = pos.coords.latitude;
      const lng = pos.coords.longitude;
      const speed = pos.coords.speed;
      const now = Date.now();

      if (!firstPositionSet) {
        countdownStart = now;
        startCountdown();
        firstTrackingTime = now;
        firstPositionSet = true;
      }

      lastUpdateTime = now;
      currentSpeed = (typeof speed === "number" && !isNaN(speed)) ? speed : null;

      fetch('http://localhost:3000/api/gps/update', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
          speed: currentSpeed,
          distance: distanceCovered,
          timestamp: Date.now()
           })
          });


      const currentPoint = turf.point([lng, lat]);
      const snapped = turf.nearestPointOnLine(turfLine, currentPoint);
      const snappedLatLng = [snapped.geometry.coordinates[1], snapped.geometry.coordinates[0]];

      if (currentSpeed !== null) {
        speedSamples.push(currentSpeed);
        if (smoothedSpeed === null) {
          smoothedSpeed = currentSpeed;
        } else {
          smoothedSpeed = smoothedSpeed * (1 - SMOOTHING_FACTOR) + currentSpeed * SMOOTHING_FACTOR;
        }
      }
      if (speedSamples.length > 0) {
        const sum = speedSamples.reduce((a, b) => a + b, 0);
        averageSpeed = sum / speedSamples.length;
      } else {
        averageSpeed = 0;
      }

      pointMarkers.forEach(m => {
        if (m.options.color === 'red') map.removeLayer(m);
      });

      const redMarker = L.circleMarker(snappedLatLng, { color: 'red', radius: 6 }).addTo(map);
      pointMarkers.push(redMarker);
      const gpsMarker = L.circleMarker([lat, lng], { color: 'yellow', radius: 4 }).addTo(map);
      pointMarkers.push(gpsMarker);

      const distanceAlong = snapped.properties.location * 1000;

      if (prevAlong !== null) {
        let diff = distanceAlong - prevAlong;
        if (diff < -totalDistance * 0.5) {
          diff = (totalDistance - prevAlong) + distanceAlong;
          lapsCompleted++;
        }
        if (diff > 0) {
          totalDistanceTravelled += diff;
        }
      }
      prevAlong = distanceAlong;

      distanceCovered = totalDistanceTravelled;
      distanceToGoal = Math.max((lapsCompleted + 1) * totalDistance - distanceCovered, 0);
      centerMap(lat, lng);
    }

    function finishRun() {
      if (!trackingStarted) return;
      trackingStarted = false;
      if (gpsWatcher !== null) {
        navigator.geolocation.clearWatch(gpsWatcher);
        gpsWatcher = null;
      }

      finalDistance = distanceToGoal;
      toggleBtn.disabled = true;

      if (finalDistance !== null) {
        const totalLaps = distanceCovered / totalDistance;
        const finalAvg = averageSpeed * 3.6;
        const finalTime = (Date.now() - firstTrackingTime - totalPausedTime) / 1000;
        infoBox.innerHTML += `<br>üèÅ Zielabstand: ${finalDistance.toFixed(1)} m`;
        infoBox.innerHTML += `<br>üîÑ Gefahrene Runden: ${totalLaps.toFixed(2)}`;
        infoBox.innerHTML += `<br>üìà √ò-Tempo: ${finalAvg.toFixed(1)} km/h`;
        infoBox.innerHTML += `<br>‚è≤Ô∏è Zeit: ${finalTime.toFixed(1)} s`;
        alert(`Abstand zur Ziellinie: ${finalDistance.toFixed(1)} m`);
      }
    }
})();
</script>
</body>
</html>
